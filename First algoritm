directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]  # Возможные направления: вверх, вниз, влево, вправо

def main_func(input_maze):
    rows = len(input_maze)
    cols = len(input_maze[0])

    start = None
    end = None

    # Ищем стартовую и конечную точки
    for i in range(rows):
        for j in range(cols):
            if input_maze[i][j] == "S":
                start = (i, j)  # Координаты старта
            elif input_maze[i][j] == "E":
                end = (i, j)  # Координаты конца

    if not start or not end:
        return -1  # Если не удалось найти стартовую или конечную точку

    # Очередь для BFS, начинается с точки старта
    queue = [(start[0], start[1], False, 0)]  # (x, y, broken_wall, steps)
    vis = [[[False, False] for _ in range(cols)] for _ in range(rows)]  # Массив посещенных клеток
    vis[start[0]][start[1]][0] = True  # Помечаем стартовую клетку как посещенную без разрушенной стены

    while queue:
        x, y, broken, steps = queue.pop(0)

        # Если мы достигли конечной точки
        if (x, y) == end:
            return steps

        # Перебираем все направления
        for direction in directions:
            dx, dy = direction
            nx, ny = x + dx, y + dy

            if 0 <= nx < rows and 0 <= ny < cols:  # Проверяем, что не выходим за границы лабиринта
                if input_maze[nx][ny] == "0" and not vis[nx][ny][broken]:  # Если проходимая клетка
                    vis[nx][ny][broken] = True
                    queue.append((nx, ny, broken, steps + 1))

                elif input_maze[nx][ny] == "1" and not broken:  # Если стена и мы еще не разрушали стену
                    if not vis[nx][ny][1]:  # Если не посещали клетку после разрушения стены
                        vis[nx][ny][1] = True
                        queue.append((nx, ny, True, steps + 1))

    return -1  # Если пути нет

# Пример лабиринта
maze = [
    ['S', '0', '1', '0', 'E'],
    ['0', '1', '0', '1', '0'],
    ['0', '0', '0', '0', '0'],
    ['1', '0', '1', '1', '1'],
    ['0', '0', '0', '0', '0']
]

res = main_func(maze)

print(res)  # Выводим результат, это длина самого короткого пути
